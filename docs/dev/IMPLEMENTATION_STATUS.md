# Codex Instruction Document 遂行状況と計画

更新日: 2025-01-XX

## 1. 全体最適化ポリシーの実装状況

### 2.1 速度向上の主な方針

| 方針 | 実装状況 | 対象Phase | 備考 |
|------|---------|----------|------|
| **1. バッチ推論の徹底** | ✅ 完了 | Phase 2, 5, 6 | `--batch-size` CLI引数で設定可能化済み |
| **2. モデルロードの一回化** | ✅ 完了 | Phase 2, 5, 6, 7 | `TextEvaluator`で評価器を1回ロード |
| **3. デバイス管理** | ✅ 完了 | 全Phase | `src/utils/device.py`で統一管理 |
| **4. ベクトル化（行列演算）** | ✅ 完了 | Phase 3, 4, 7 | torch/numpyベースの行列演算に変換済み |
| **5. I/Oとログの最小化** | ⚠️ 部分実装 | 全Phase | ループ外での集約は一部のみ |
| **6. 共通コンポーネント化** | ✅ 完了 | Phase 5, 6 | `TextEvaluator`で統一 |

---

## 2. フェーズ別実装状況

### Phase 0: インフラ・環境整備
**実装状況**: ✅ 完了
- デバイスユーティリティ（`src/utils/device.py`）
- 評価器ユーティリティ（`src/analysis/evaluation.py`）

### Phase 1: データセット & 評価設計
**実装状況**: ⚠️ 最適化未実施（低優先度）
- **未実装タスク**:
  - ファイル I/O や JSONL 書き込みのまとめ
  - 不要なループでの json.dumps 多用のバッファリング

**優先度**: 🟢 低（負荷が軽いため）

### Phase 2: 活性抽出
**実装状況**: ✅ 完了
- ✅ バッチ処理（`batch_size` 引数、デフォルト: 16）
- ✅ モデルロードは1回のみ
- ✅ hooks（residual stream）はバッチ前提
- ✅ `--batch-size` CLI引数

### Phase 3: 感情ベクトル & サブスペース構築
**実装状況**: ✅ 完了
- ✅ `_pca_torch()` を実装（GPU/MPS対応）
- ✅ `--use-torch` CLI引数（デフォルト: True）
- ✅ cosine計算は行列演算
- ✅ L1/L2 norm はベクトル化済み

### Phase 4: モデル間アライメント
**実装状況**: ✅ 完了
- ✅ `_procrustes_torch()` を実装（`torch.linalg.lstsq` 使用、MPS時は `torch.linalg.pinv` でGPU/MPSを維持）
- ✅ `_subspace_overlap_torch()` を実装（`torch.linalg.qr` 使用）
- ✅ `--use-torch` / `--no-use-torch` CLI引数（デフォルト: True）
- ✅ `--device` CLI引数でデバイス指定可能
- ✅ GPU/MPS環境で高速化可能（2-3倍の見込み）

### Phase 5: 残差ベクトルの causal patching
**実装状況**: ✅ 完了
- ✅ 小型: HookedTransformer ベースの `generate_with_patching_batch()` を実装（バケット化・非パディング）
- ✅ 大型: LargeHFModel ベースの `LargeActivationPatcher` を追加（HF generate へ前置フックで resid_pre を加算）
- ✅ `TextEvaluator.evaluate_batch()` を使用
- ✅ 評価器の初期化はループ外で1回のみ
- ✅ `--batch-size` CLI引数（デフォルト: 8、MPS/CUDAで調整可）
- ℹ️ ランダム対照はオプション（`--random-control`）。標準フローでは実行しない。

### Phase 6: Head スクリーニング & パッチング
**実装状況**: ⚠️ 部分実装
- ✅ 小型: HookedTransformer で head ablation（ゼロ化）を実装済み
- ✅ 大型: HF self_attn 出力を head 次元でゼロ化する `LargeHeadAblator` を追加（スクリーニング/パッチング両方で使用）
- ✅ バッチ生成と評価、`--batch-size` CLI引数（デフォルト: 8）
- ❌ head patching（中立→感情／感情→中立）は未実装（pattern_v / v_only も未実装）

**未実装タスク**:
- pattern_v / v_only での head-level patching
- Phase 5 のバッチ化実装を基盤として活用可能

**優先度**: 🟢 低（現状の ablation でも因果効果は測定可能）

### Phase 7: 統計的厳密性
**実装状況**: ✅ 完了
- ✅ bootstrap 計算を並列化（joblib使用）
- ✅ `--n-jobs` CLI引数（デフォルト: 1）
- ✅ `effect_sizes.py` と `k_selection.py` の両方で並列化
- ✅ 計算のベクトル化（numpyベース）

### Phase 8: 回路レベル解剖
**実装状況**: ❌ 未実装（構想段階）
- OV/QK 行列解析モジュールの実装
- 複数 head を同時に patch / ablate する機構の実装
- 回路単位の因果効果測定の実装

**優先度**: 🟢 低（将来の拡張）

---

## 3. 検証・テスト指示の実装状況

### 6.1 スモークテスト用の --max-samples / --dry-run オプション
**実装状況**: ⚠️ 部分実装
- Phase 5 に `--max-samples-per-emotion` が存在
- Phase 2, 6, 7 への追加が必要か確認

**優先度**: 🟡 中

### 6.2 数値の変化が小さいことの確認
**実装状況**: ❌ 未実装
- Before / After の出力を比較するスクリプトが存在しない
- 簡易スクリプトまたはノートブックの追加が必要

**優先度**: 🟡 中

### 6.3 パフォーマンスログの追加
**実装状況**: ⚠️ 部分実装
- Phase 7 で処理時間をログ出力
- 他のPhaseへの展開が必要

**優先度**: 🟢 低

---

## 4. I/Oとログの最小化の実装状況

### 2.1.5 I/Oとログの最小化
**実装状況**: ⚠️ 部分実装

**現状**:
- Phase 7 で処理時間をログ出力（ループ外）
- 一部のPhaseでループ内にprint文が残っている可能性

**未実装タスク**:
- 全Phaseでループ内のprint/loggingをループ外に集約
- 高頻度 I/O のバッファリング（例: 100サンプルごと）
- MLflowログの集約

**優先度**: 🟡 中

---

## 5. 推奨される実装計画

### 🔴 高優先度（即座に対応）

#### 1. 数値検証スクリプトの実装
**対象**: 新規スクリプト `scripts/verify_refactoring.py`

**実装内容**:
- Before / After の出力比較機能
- 許容範囲内の差分確認（1e-3〜1e-2）
- スモークテスト用の簡易スクリプト

**期待される効果**:
- リファクタリング後の数値整合性の保証
- 回帰テストの自動化

**実装工数**: 中（2-3時間）

---

### 🟡 中優先度（次に対応）

#### 2. I/Oとログの最小化（全Phase）
**対象**: 全Phaseスクリプト

**実装内容**:
- ループ内のprint/loggingをループ外に集約
- 高頻度 I/O のバッファリング
- MLflowログの集約（オプション）

**期待される効果**:
- I/Oオーバーヘッドの削減
- ログの可読性向上

**実装工数**: 中（各Phase 1-2時間）

**優先順位**:
1. Phase 5（最重フェーズ）
2. Phase 2（活性抽出）
3. Phase 6（head screening/patching）
4. Phase 3, 4, 7（その他）

---

#### 3. スモークテストオプションの統一
**対象**: Phase 2, 6, 7

**実装内容**:
- `--max-samples-per-emotion` または `--dry-run` オプションの追加
- Phase 5 の実装を参考に統一

**期待される効果**:
- 開発・テスト時の高速化
- 一貫したインターフェース

**実装工数**: 小（各Phase 30分-1時間）

---

### 🟢 低優先度（時間があるときに対応）

#### 4. Phase 1 の最適化
**対象**: `src/data/` 配下のスクリプト

**実装内容**:
- ファイル I/O や JSONL 書き込みのまとめ
- 不要なループでの json.dumps 多用のバッファリング

**優先度の理由**:
- 負荷が相対的に軽い
- 実行頻度が低い

**実装工数**: 小（1-2時間）

---

#### 5. Phase 6 の head patching 実装
**対象**: `src/analysis/run_phase6_head_patching.py` または新規スクリプト

**実装内容**:
- pattern_v モード: attention pattern を感情プロンプトから取得して注入
- v_only モード: value ベクトルのみを注入
- Phase 5 のバッチ生成ロジックを再利用

**優先度の理由**:
- 現状の ablation でも因果効果は測定可能
- 実装コストが高い（hook の複雑な操作が必要）

**実装工数**: 大（4-6時間）

---

#### 6. パフォーマンスログの追加（全Phase）
**対象**: 全Phaseスクリプト

**実装内容**:
- 各処理ステップの実行時間を詳細に記録
- MLflow への自動記録（オプション）
- ボトルネックの可視化

**優先度の理由**:
- 既にPhase 7で実装済み
- 他のPhaseへの展開は低優先度

**実装工数**: 中（各Phase 30分-1時間）

---

#### 7. Phase 8 パイプラインの実装
**対象**: 新規スクリプト `src/analysis/run_phase8_pipeline.py`

**実装内容**:
- Phase 3/4 相当の処理を大規模モデル向けに実装
- `LargeHFModel` を使用した活性抽出（バッチ処理）
- Phase 4 のアライメント計算ロジックを再利用

**優先度の理由**:
- 将来の拡張として位置づけ
- 現時点では必要性が低い

**実装工数**: 大（8-12時間）

---

## 6. 実装ロードマップ（推奨順序）

### フェーズ1: 検証基盤の整備（1-2週間）
1. ✅ 数値検証スクリプトの実装
2. ✅ スモークテストオプションの統一

### フェーズ2: I/O最適化（2-3週間）
3. ✅ Phase 5 のI/Oとログの最小化
4. ✅ Phase 2 のI/Oとログの最小化
5. ✅ Phase 6 のI/Oとログの最小化
6. ✅ Phase 3, 4, 7 のI/Oとログの最小化

### フェーズ3: 機能拡張（時間があるとき）
7. ⏳ Phase 1 の最適化
8. ⏳ Phase 6 の head patching 実装
9. ⏳ パフォーマンスログの追加（全Phase）
10. ⏳ Phase 8 パイプラインの実装

---

## 7. 完了率サマリー

### 全体最適化ポリシー
- ✅ バッチ推論の徹底: 100%
- ✅ モデルロードの一回化: 100%
- ✅ デバイス管理: 100%
- ✅ ベクトル化（行列演算）: 100%
- ⚠️ I/Oとログの最小化: 30%
- ✅ 共通コンポーネント化: 100%

**全体完了率**: 約 88%

### フェーズ別実装状況
- Phase 0: ✅ 100%
- Phase 1: ⚠️ 0%（最適化未実施、低優先度）
- Phase 2: ✅ 100%
- Phase 3: ✅ 100%
- Phase 4: ✅ 100%
- Phase 5: ✅ 100%
- Phase 6: ⚠️ 80%（head patching 未実装）
- Phase 7: ✅ 100%
- Phase 8: ❌ 0%（将来の拡張）

**フェーズ完了率**: 約 87%

### 検証・テスト指示
- ⚠️ スモークテストオプション: 50%
- ❌ 数値検証スクリプト: 0%
- ⚠️ パフォーマンスログ: 30%

**検証完了率**: 約 27%

---

## 8. 次のアクション

### 即座に実施すべきタスク
1. **数値検証スクリプトの実装**（`scripts/verify_refactoring.py`）
   - リファクタリング後の数値整合性を保証
   - 回帰テストの自動化

### 次週に実施すべきタスク
2. **Phase 5 のI/Oとログの最小化**
   - 最重フェーズのI/Oオーバーヘッド削減
   - ログの可読性向上

3. **スモークテストオプションの統一**
   - Phase 2, 6, 7 への `--max-samples-per-emotion` 追加
   - 開発・テスト時の高速化

---

## 9. 注意事項

- **後方互換性**: すべての変更で既存のCLI引数と出力フォーマットを維持
- **テスト**: 各最適化後にスモークテストを実行して数値の整合性を確認
- **ドキュメント**: 新しい機能の使用例を README に追加
- **段階的実装**: 大きな変更はファイル単位 / フェーズ単位で PR を分ける
